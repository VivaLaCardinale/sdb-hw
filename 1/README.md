# Домашнее задание к занятию "`Базы данных, их типы`" - `Минаевой Екатерины`

### Задание 1. СУБД

*Кейс*
*Крупная строительная компания, которая также занимается проектированием и девелопментом, решила создать правильную архитектуру для работы с данными. Ниже представлены задачи, которые необходимо решить для каждой предметной области.
Какие типы СУБД, на ваш взгляд, лучше всего подойдут для решения этих задач и почему?*

1. *Бюджетирование проектов с дальнейшим формированием финансовых аналитических отчётов и прогнозирования рисков. СУБД должна гарантировать целостность и чёткую структуру данных.*

Рекомендуемый тип: Реляционные СУБД (RDBMS) с поддержкой аналитических функций (например: PostgreSQL, Oracle Database, Microsoft SQL Server).
Почему:
* ACID-соответствие: Гарантирует целостность транзакций, так как в финансах недопустима потеря даже одной записи о платеже.
* Строгая схема (Schema-on-write): Четкая структура таблиц исключает появление некорректных данных.
* Сложные связи: Бюджеты связаны со сметами, контрагентами, графиками работ и т.д. — реляционная модель идеально описывает эти зависимости.
* Аналитика: Современные RDBMS отлично справляются со сложными SQL-запросами для формирования отчетности.

2. *Под каждый девелоперский проект создаётся отдельный лендинг, и все данные по лидам стекаются в CRM к маркетологам и менеджерам по продажам. Какой тип СУБД лучше использовать для лендингов и для CRM? СУБД должны быть гибкими и быстрыми.*

Рекомендуемый тип: Документоориентированные NoSQL СУБД (например: MongoDB, Couchbase).
Почему:
* Гибкость схемы (Dynamic Schema): Маркетинговые лендинги часто меняются, а NoSQL позволяет добавлять поля без остановки системы.
* Скорость: NoSQL базы оптимизированы для быстрой записи (лиды) и чтения (отображение контента на лендинге).
* Интеграция: Данные в CRM часто поступают в формате JSON, который является «родным» для документоориентированных баз, что упрощает обмен данными между маркетинговыми инструментами и CRM.

3. *Отдел контроля качества решил создать базу по корпоративным нормам и правилам, обучающему материалу и так далее, сформированную согласно структуре компании. СУБД должна иметь простую и понятную структуру.*

Рекомендуемый тип: Объектно-реляционные СУБД или специализированные Content Management базы (например, PostgreSQL (с расширениями для полнотекстового поиска) или использование систем на базе Wiki-движков).
Почему:
* Иерархическая структура: Позволяет легко выстроить дерево.
* Полнотекстовый поиск: Сотрудникам важно быстро находить информацию по ключевым словам в нормах и правилах.
* Простота администрирования: Для текстового контента и медиафайлов не нужны сложные распределенные системы. Реляционной базы с хорошей структурой достаточно для обеспечения понятной навигации.

4. *Департамент логистики нуждается в решении задач по быстрому формированию маршрутов доставки материалов по объектам и распределению курьеров по маршрутам с доставкой документов. СУБД должна уметь быстро работать со связями.*

Рекомендуемый тип: Графовые СУБД (например: Neo4j, Memgraph, Amazon Neptune).
Почему:
* Работа со связями: В логистике объекты (склады, стройплощадки, офисы) — это узлы, а дороги/маршруты — это связи. Графовые СУБД ищут кратчайшие пути и обходят графы в разы быстрее, чем реляционные базы с их тяжелыми операциями JOIN.
* Динамичность: Легко добавлять новые точки и изменять веса ребер (например, учитывать пробки или закрытие дорог в реальном времени).
* Оптимизация: Задачи распределения курьеров математически эффективнее решаются именно на графовых структурах.

---

### Задание 2. Транзакции

*Пользователь пополняет баланс счёта телефона, распишите пошагово, какие действия должны произойти для того, чтобы транзакция завершилась успешно. Ориентируйтесь на шесть действий.*

Цепочка действий, приведенная ниже, гарантирует выполнение принципа атомарности транзакции. Т.е. либо все этапы завершаются успешно и баланс пополняется, либо (в случае сбоя на любом этапе) система делает «откат», и деньги возвращаются пользователю.

1. Инициация и авторизация (Запрос). Пользователь вводит сумму и реквизиты в приложении банка или платежном сервисе. Система проверяет наличие средств на источнике оплаты и подлинность пользователя.
2. Проверка сотового оператора (Валидация).
3. Блокировка средств (Hold).
4. Передача данных через процессинг. Информация о транзакции передается через платежную систему.
5. Подтверждение зачисления (Финализация). Получение уведомления об успешном резервировании средств.
6. Взаиморасчеты (Клиринг). Банк-эмитент окончательно списывает средства и переводит их банку-эквайеру.

---

### Задание 3. SQL vs NoSQL

*Напишите пять преимуществ SQL-систем по отношению к NoSQL.*

1. Строгое соблюдение ACID-транзакций (SQL-базы данных изначально проектировались для обеспечения ACID (Atomicity, Consistency, Isolation, Durability)).
Это гарантирует, что любая транзакция либо выполняется полностью, либо не выполняется вовсе, сохраняя целостность данных даже при сбоях системы. В финансовых системах или системах бронирования это критически важно: нелзя допустить, чтобы деньги списались со счета, но не зачислились получателю. Многие NoSQL-решения предлагают лишь «согласованность в конечном счете» (eventual consistency).
2. Мощный и стандартизированный язык запросов (SQL).
SQL позволяет выполнять сложнейшие выборки, агрегации и объединения данных из разных таблиц с помощью лаконичного кода. В NoSQL-системах для аналогичных операций часто приходится писать сложную программную логику на стороне приложения. Стандартизация также означает огромный рынок специалистов и легкую замену одной реляционной БД на другую (например, с PostgreSQL на MySQL).
3. Нормализация и отсутствие дублирования данных.
Это исключает аномалии обновления. В NoSQL (например, MongoDB) данные часто дублируются ради скорости чтения, что делает поддержку их актуальности крайне сложной и ресурсозатратной задачей.
4. Целостность данных на уровне схемы.
В SQL структура данных (таблицы, типы полей, связи) жестко определена до начала записи. Это обеспечивает автоматическую проверку данных «на входе». Система просто не позволит записать текст в поле для даты или вставить ID несуществующего пользователя. В NoSQL ответственность за валидацию данных полностью ложится на разработчика приложения, что в крупных проектах часто приводит к накоплению «загрязненных» или неполных данных, которые сложно анализировать.
5. Развитая экосистема и инструменты бизнес-аналитики.
Почти все современные инструменты аналитики, отчетности и визуализации данных (Tableau, Power BI и др.) нативно работают с SQL. Благодаря табличной структуре и предсказуемости, SQL-базы данных являются идеальным источником для бизнес-аналитики. Извлечение сложных инсайтов из разрозненных JSON-документов NoSQL-баз требует дополнительных этапов трансформации (ETL), что замедляет процесс принятия решений.

---

### Задание 4. Кластеры

*Необходимо производить большое количество вычислений при работе с огромным количеством данных, под эту задачу выделено 1000 машин. На основе какого критерия будете выбирать тип СУБД и какая модель распределённых вычислений здесь справится лучше всего и почему?*

Для решения задачи идеальной связкой будет использование распределенной файловой системы или NoSQL СУБД в качестве хранилища и Apache Spark в качестве движка вычислений. Это обеспечит максимальную загрузку всех 1000 машин, минимизирует сетевой трафик и гарантирует завершение вычислений даже при отказе нескольких десятков серверов.

Для работы с огромными данными на кластере из 1000 машин выбор технологий должен основываться на следующих критериях:

1. Критерий выбора СУБД: Горизонтальная масштабируемость.
При большом количестве узлов (1000 машин) ключевым критерием является линейная горизонтальная масштабируемость. Реляционные СУБД обычно масштабируются вертикально (увеличением мощности одного сервера). Для 1000 машин необходима система, которая позволяет добавлять узлы без деградации производительности. Оптимальным выбором будут NoSQL системы (например, Cassandra, ScyllaDB) или MPP-системы (Massively Parallel Processing, например, ClickHouse, Greenplum).
2. Модель распределенных вычислений.
Лучше всего с такой задачей справится модель MapReduce (реализованная в Apache Hadoop) или её более современный и быстрый аналог — Apache Spark.
Почему это лучшее решение:
* Локальность данных. Вместо того чтобы перекачивать терабайты данных по сети к вычислительному узлу, MapReduce отправляет код (программу) на те узлы, где данные уже лежат физически. Это критично для 1000 машин, так как пропускная способность сети всегда является узким местом.
* Отказоустойчивость. На кластере из 1000 машин вероятность выхода из строя хотя бы одного узла во время вычислений близка к 100%. Модель MapReduce автоматически перезапускает задачи (tasks) выпавших узлов на других машинах, не прерывая весь процесс вычислений.
* Масштабируемость:
    * Map: Разбивает огромную задачу на мелкие части и обрабатывает их параллельно на 1000 узлах.
    * Shuffle/Sort: Перераспределяет промежуточные результаты.
    * Reduce: Агрегирует результаты в финальный ответ.

---
